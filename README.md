بخش ۱

در نسخه اولیه سیستم مدیریت درخواست‌ها، طراحی شی‌گرا به‌درستی رعایت نشده بود و وابستگی‌های زیاد و شرط‌های متعدد باعث کاهش خوانایی و توسعه‌پذیری سیستم شده بود.

در این بخش، سیستم به زیرمسائل مستقل شکسته شده و برای هر بخش الگوی مناسب پیشنهاد شده است.

________________________________________________________________________________________________________________________________________________________________________________________________________
1.مدیریت وضعیت‌های درخواست (Ticket Lifecycle) 

شرح مسئله

هر Ticket در طول عمر خود چند وضعیت متوالی را طی می‌کند:


•	Created

•	Assigned

•	In Progress

•	Resolved

•	Closed

رفتار سیستم در هر وضعیت متفاوت است و وابسته به State فعلی می‌باشد.

الگوی پیشنهادی: State Pattern

دلیل انتخاب:

رفتار وابسته به حالت است. استفاده از شرط‌های if/else متعدد منجر به افزایش پیچیدگی می‌شود.

با استفاده از الگوی State، رفتار هر وضعیت در کلاس مخصوص به خود پیاده‌سازی می‌شود.

نحوه اعمال:
•	Ticket به عنوان Context

•	TicketState به عنوان Interface

•	پیاده‌سازی Concrete Stateها برای هر وضعیت

________________________________________
2. پردازش درخواست بر اساس نوع آن
   
شرح مسئله

درخواست‌ها بسته به نوع (فنی، مالی، عمومی و ...) دارای الگوریتم پردازش متفاوت هستند.

الگوی پیشنهادی: Strategy Pattern

دلیل انتخاب:

چندین الگوریتم مختلف برای یک عملیات مشترک وجود دارد و این الگوریتم‌ها قابل جایگزینی هستند.

نحوه اعمال:

•	تعریف Interface به نام ProcessingStrategy

•	پیاده‌سازی کلاس‌های:

o	TechnicalProcessing

o	FinancialProcessing

o	GeneralProcessing

•	تزریق Strategy مناسب هنگام ایجاد Ticket

________________________________________
3.ایجاد Ticket بر اساس نوع درخواست

شرح مسئله:

ایجاد Ticket بر اساس نوع آن انجام می‌شود و وابسته به نوع، Strategyهای متفاوتی باید به آن اختصاص داده شود.

الگوی پیشنهادی: Factory Pattern

دلیل انتخاب:

منطق ایجاد شیء نباید در کلاس اصلی قرار گیرد.

Factory مسئول ساخت و پیکربندی شیء مناسب است.

نحوه اعمال:

•	تعریف کلاس TicketFactory

•	متد createTicket(String type)

•	ایجاد Ticket به همراه Strategyهای مناسب

________________________________________
4. تولید پاسخ به درخواست:
   
شرح مسئله:

نوع پاسخ نیز وابسته به نوع Ticket است.

الگوی پیشنهادی: Strategy Pattern

دلیل انتخاب:

پاسخ‌دهی شامل چندین الگوریتم قابل تعویض است.

نحوه اعمال:

•	تعریف Interface به نام ResponseStrategy

•	پیاده‌سازی Concrete Responseها برای هر نوع درخواست

________________________________________
5. ثبت رویدادها (Logging)
   
شرح مسئله:

پس از هر عملیات، باید یک Log در سیستم ثبت شود.

الگوی پیشنهادی: Singleton Pattern

دلیل انتخاب:

Logger باید در کل سیستم فقط یک نمونه داشته باشد تا رفتار یکنواخت و کنترل‌شده‌ای ارائه دهد.

نحوه اعمال:

•	تعریف کلاس Logger

•	سازنده private

•	متد static getInstance()

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
بخش 2 :

<img width="1024" height="1024" alt="class-diagram" src="https://github.com/user-attachments/assets/b050b800-f274-42ed-83a8-7bd4f15e23d8" />

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

بخش 3:



در نسخه اولیه، رفتارهای مختلف در داخل یک یا چند کلاس متمرکز شده و با شرط‌های متعدد کنترل می‌شدند.

پس از اعمال الگوهای طراحی:

•	شرط‌های پیچیده حذف شدند

•	رفتار وابسته به حالت به کلاس‌های State منتقل شد

•	الگوریتم‌های پردازش و پاسخ به Strategyها واگذار شدند

•	ایجاد شیء به Factory منتقل شد

•	سیستم لاگینگ به صورت Singleton پیاده‌سازی شد

در نتیجه، کد به صورت ماژولار، قابل توسعه و قابل نگهداری درآمد.

//////////////////////////////////////////////////////////////////////////////////////////////


بخش ۴

SRP:

هر کلاس تنها یک مسئولیت مشخص دارد.

OCP:

برای افزودن نوع جدید Ticket، تنها کافی است Strategy جدید تعریف شود و نیازی به تغییر کلاس‌های موجود نیست.

LSP:

تمام Concrete Stateها و Strategyها قابل جایگزینی با Interface مربوطه هستند.

ISP:

اینترفیس‌ها کوچک و متمرکز طراحی شده‌اند.

DIP:

کلاس‌های سطح بالا به Abstraction وابسته‌اند نه پیاده‌سازی.

PLK:

کلاس‌ها فقط با وابستگی مستقیم خود ارتباط دارند.

CRP:

به جای استفاده بیش از حد از وراثت، از Composition استفاده شده است.


